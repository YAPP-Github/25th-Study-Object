## 서브 클래스와 서브타이핑

상속의 첫 용도는 타입 계층을 구현하는 것

- 일반화
- 특수화

상속의 목표는 타입 계층을 구현하는 것으로 부모와 자식을 강하게 결합시킴

- 타입 계층을 목표로 상속을 사용할 경우 다형적으로 동작하는 객체들의 관계에 기반에 확장 가능하고 유연한 설계를 얻을 수 있다.
- 동일한 메시지에 대해 서로 다르게 행동할 수 있다

## 객체 지향 프로그래밍과 객체 기반 프로그래밍

- 객체 기반 프로그래밍
    - 상태와 행동을 캡슐화한 객체를 조합하여 프로그램을 구성하는 방식
- 객체 지향 프로그래밍
    - 객체 기반 프로그래밍의 하나
    - 상속과 다형성을 지원한다는 점이 객체 기반 프로그래밍과 차별

## 타입

- 개념 관점의 타입
- 프로그래밍 언어 관점의 타입

## 객체 지향 패러다임 관점의 타입

객체가 수신할 수 있는 메시지의 집합을 퍼블릭 인터페이스

- 객체지향에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일

타입 사이의 포함관계

- 타입 계층을 구성하는 두 타입간의 관계에서 더 일반적인 타입을 슈퍼타입이라 부르고 특수한 타입을 서브타입이라고 부른다.

## 객체지향 프로그래밍과 타입 계층

- 일반적으로 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼 타입
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스

## 언제 상속을 사용해야 하는가?

상속의 올바른 용도는 타입 계층을 구현하는 것

- 클라이언트 입장에서 부모 클래스의 타입으로 자식클래스를 사용해도 무방

## 행동 호환성

즉, 상속 계층을 사용하는 클라이언트는 부모와 자식 클래스 차이를 몰라야함

## 클라이언트의 기대에 따라 계층 분리하기

- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(ISP) 라고 부름

## 서브 클래싱과 서브 타이핑

- 서브 클래싱: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킴.
  자식과 부모의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없음. 구현상속. 클래스 상속이라고 부름
- 서브타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킴. 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브 타입이 됨.

## 리스코프 치환 원칙

올바른 상속 관계의 특징을 정의하기 위해 리스코프 치환 원칙을 정의

- 서브타입은 그것의 기반 타입에 대해 완전히 대체 가능해야함
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야한다.

## 리스코프 치환 원칙은 유연한 설계의 기반

클라이언트의 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있음

## 계약에 의한 설계

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현한 것

- 사전조건 - 클라이언트가 메서드를 실행하기 위해 만족시켜야하는 조건
- 사후조건 - 메서드가 실행된 후 서버가 클라이언트에게 보장해야 하는 조건
- 클래스 불변식 - 메서드 실행 전 후 인스턴스가 만족시켜야 하는 조건

## 서브타입과 계약

계약의 관점에서 상속의 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 수 있다는 점

- 서브타입에 더 강력한 사전조건을 정의할 수 없다
- 서브타입에 슈퍼타입과 같거나 약한 사전조건을 정의할 수 없다
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다
- 서브타입에 더 약한 사후 조건을 정의할 수 없다