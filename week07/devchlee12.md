### 프로시저 추상화와 데이터 추상화

- 현대 프로그래밍 언어를 특징짓는 중요한 두가지 추상화 매커니즘
    - 프로시저 추상화
        - 무엇을 해야하는지
        - 기능 분해 (알고리즘 분해)
    - 데이터 추상화
        - 무엇을 알아야하는지
        - 데이터 중심, 타입 추상화
            - 추상 데이터 타입
        - 데이터 중심, 프로시저 추상화
            - 객체지향
- 왜 전통적인 기능분해보다 객체지향 분해방법이 효과적일까?

### 프로시저 추상화와 기능 분해

- 기능적 추상화 - 메인 함수로서의 시스템
    - 하향식 접근법으로 분해
        - 상위 기능을 작게 분해해나가는 것
    - 프로시저만으로는 정보 은닉 체계 구축 한계 있음
- 급여 관리 시스템 설계의 예시 - 하향식 접근법
    - 급여 = 기본급 - (기본급 * 소득세율)
    - 최상위 문장 기술 → 직원의 급여를 계산한다
    - 세분화된 절차로 구체화 → 소득세율 입력, 급여 계산, 양식에 맞게 결과 출력
    - 기능분해의 결과는 목차 정리하고 내용 채워넣는것
    - 기능이 우선, 데이터는 뒤를 따름
        - 유지보수에 문제 야기 → 구현보면 알 수 있음
- 급여 관리 시스템 구현의 예시 - 하향식 접근법
    
    ![ha](https://github.com/user-attachments/assets/34c82432-6845-43b1-ab5d-2cc1aca18bd9)

    
    - 체계적으로 보이지만, 문제는 우리 세상이 체계적이지 않다는 것
- 하향식 기능 분해의 문제점
    - 시스템은 하나의 메인함수로 구성되지 않음
        - 처음에는 중요하게 생각했던 함수가 나중에는 그저그런 함수가 됨
        - 지금 사용하고 있는 시스템을 트리로 정리 가능한가? 불가능.
    - 기능 추가나 요구사항 변경 때문에 메인 함수 빈번히 수정해야함
        - 새 기능 추가할 때마다 직접 메인함수 수정해야함 → 버그 확률 up
    - 비즈니스 로직이 사용자 인터페이스와 강하게 결합
        - 하향식 접근법은 초기 단게부터 입력방법과 출력양식을 함께 고민하게함
        - 따라서 변경이 자주 일어나는 사용자 인터페이스와 변경이 잘 되지 않는 비즈니스 로직이 결합됨
            - so, 변경에 불안정한 아키텍처 낳음
    - 하향식 분해는 너무 이른시기에 함수들의 실행 순서 고정 → 유연성, 재사용성 저하
        - 기능 분해 방식은 중앙 집중 제어 스타일의 형태를 띨 수 밖에 없음
        - 문제는 제어구조가 빈번한 변경 대상인 것
        - 하향식 접근법을 통해 분해한 함수들은 재활용도 어려움 ← 맥락안에서만 의미 가지니까
    - 데이터 형식 변경 → 파급효과 예측 불가
        - 가장 큰 문제
        - 어떤 데이터를 어떤 함수가 사용하고 있는지 추적 어려움
        - 데이터의 변경으로 인한 영향은 데이터 직접  참조하는 모든 함수로 퍼져나감
        - 데이터 변경에 의한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확히 분리해야
            - 의존성 관리
    - 하향식 분해가 유용한 경우
        - 설계 안정화되면 문서화 용이
        - 다만 문서화에 적절한 방법이 좋은 구조를 낳지는 않음
        - 하향식은 이미 이해된 사실을 서술하기에 적합하지만, 새로운 것을 개발하는데에는 적합한 방법이 아님

### 모듈

- 정보 은닉과 모듈
    - 시스템의 변경 관리 전략
        - 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근
    - 정보 은닉이란?
        - 자주 변경되는 부분을 덜 변경되는 안정적인 인터페이스 뒤로 감춰라
    - 모듈
        - 변경될 가능성이 있는 비밀 내부에 감추고 변경되지 않을 퍼블릭 인터페이스 외부에 제공
    - 모듈로 분해한 뒤에는 모듈 내부에서 기능분해 적용 간으
    - 시스템을 모듈단위로 어떻게 분해할까?
        - 시스템이 감춰야하는 비밀 찾기 → 퍼블릭 인터페이스로 방어
        - 비밀이란?
            - 복잡성
            - 변경 가능성
        - 비밀이 반드시 데이터일 필요는 없음
            - 복잡한 로직이나 변경 가능성이 큰 자료구조 일수도
            - 일반적으로 데이터가 비밀이기 때문에 캡슐화와 정보은닉 개념이 혼란스러워짐
    - 급여관리 시스템을 구원하려면 모듈 만들어야함
        - 전역 변수들을 모듈 내부로
        - 퍼블릭 인터페이스 제공
- 모듈의 장점과 한계
    - 장점
        - 모듈 내부 변수 변경되어도 내부에만 영향 미침
        - 비즈니스 로직과 사용자 인터페이스에 대한 관심사 분리
        - 전역 변수와 전역 함수를 제거해서 네임스페이스 오염 방지
        - 데이터와 함수가 통합된 한 차원 높은 추상화를 제공
    - 단점
        - 인스턴스의 개념 제공 안함
            - 직원 전체가 아니라 개별 직원을 독립적인 단위로 못다룸
            - 이를 만족시키기 위해 추상데이터 타입 등장
    

### 데이터 추상화와 추상 데이터 타입

- 추상 데이터 타입
    - 추상 객체의 클래스를 정의한 것
    - 추상 객체에 사용할 수 있는 오퍼레이션 이용해서 규정됨
    - 데이터 추상화를 기반으로 개발 가능하게 하는 첫걸음
- 추상 데이터 타입으로 급여 시스템 개선하기
    - 캡슐화할 데이터 결정
    - 추상 데이터 타입에 적용할 수 있는 오퍼레이션 결정
- 추상 데이터 타입은 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준향상시킴
- 다만, 여전히 데이터와 기능을 분리해서 바라봄

### 클래스는 추상 데이터 타입인가?

- 대부분의 프로그래밍 서적은 클래스를 추상 데이터 타입으로 설명
- 하지만 명확한 의미에서는 동일하지 않음
    - 클래스 → 상속, 다형성 지원 (객체 지향)
    - 추상데이터 타입 → 상속,다형성 지원 안함 (객체 기반)
- 추상데이터 타입은 타입 추상화, 클래스는 절차 추상화
- 추상 데이터 타입에서는 알바와 정규직 공존
    - 구체적인 타입을 외부에 캡슐화
- 객체지향은 타입 기준으로 오퍼레이션 묶음
    - 정규직이랑 알바 명시적 정의하고 오퍼레이션 실행 절차를 분배
    - 그러면 공통 로직어디?
        - 부모 클래스
        - 다형성
- 따라서 ADT와 OOP는 다름
- ADT 에서 클래스로
    - 두개 타입 존재를 명시적으로 표현
    - 정규직이랑 알바를 다른 클래스로 구현
- 변경을 기준으로 선택하라
    - 타입을 기준으로 절차 추상화해야 객체지향 분해
    - 확인 방법
        - 클래스 내부에 인스턴스 타입 표현 변수 확인
            - 이거 있으면 객체지향 위반
        - 객체지향은 조건문을 다형성으로 대체
    - 객체지향으로하면 OCP 만족 가능
    - 그러면 ADT는 항상 최악인가?
        - 타입 추가 압력이 강하면 객체지향 승
        - 오퍼레이션 추가 압력이 강하면 ADT 승
- 협력이 중요하다
    - 클래스 계층에 오퍼레이션 구현 방법 분배가 객체지향 설계는 아님
    - 역할, 책임, 협력이 가장 중요
