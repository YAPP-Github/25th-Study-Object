### 다형성

- 다형성의 종류
    - 유니버설 다형성
        - 매개변수 다형성 : 타입을 임의의 타입으로 선언하고 사용시점에 지정
        - 포함 다형성 : 메시지 수신 객체에 따라 행동 달라짐
    - 임시 다형성
        - 오버로딩 : 시그니처 다르지만 동일한 이름 메서드 정의 가능
        - 강제 : 동일한 연산자를 다양한 타입에 사용
    - 이번장에서는 포함다형성에 대해 중점적으로 다룸

### 상속의 양면성

- 상속의 목적은 코드 재사용이 아니고, 다형성을 위한 타입 계층 구축임
- 상속은 두가지 관점에서 볼 수 있음
    - 데이터 관점의 상속
        - 자식 클래스의 인스턴스 안에 부모클래스의 인스턴스 포함하는 것
    - 행동 관점의 상속
        - 부모 클래스가 정의한 일부 메서드를 자식클래스의 메서드로 포함하는 것
        - 메서드 탐색 과정을 통해 부모의 메서드를 실행 가능

### 업캐스팅과 동적 바인딩

- 업캐스팅
    - 상속을 사용하면 부모의 퍼블릭 인터페이스를 물려받기 때문에 명시적인 타입없이 자식클래스가 부모 클래스 대체 가능
    - 부모가 자식 타입에 들어가려면 명시적 캐스팅으로 다운캐스팅해야함
- 동적 바인딩
    - 정적바인딩은 컴파일 타임에 메시지 수신시 호출 함수 결정함
    - 반면에 동적 바인딩은 실행 시점에 메시지 수신시 호출 함수 결정함

### 동적 메서드 탐색과 다형성

- self 참조
    - 객체가 메시지를 수신하면 컴파일러가 self 참조라는 임시 변수 생성해서 메시지 수신한 객체 가리키도록 설정함
    - 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄짐
    - 그래서 자식 클래스의 메서드가 부모 클래스의 메서드 보다 우선순위 높음
- 동적 메서드 탐색의 원리
    - 자동적인 메시지 위임
        - 이해할 수 없으면 부모클래스에게 자동으로 처리 위임
        - 이런 관점으로 보면 상속 계층 정의는 메서드 탐색 경로 정의와 동일
    - 동적인 문맥 사용
        - 실행시점에 실행 메서드 결정
        - self참조가 가리키는 객체부터 탐색하기때문에 메서드 탐색을 위한 상속게층의 범위가 동적으로 변함
        - 메서드 탐색하는 도중에도 self 참조는 처음과 같이 유지됨
        - 부모 클래스의 메서드 실행할 때도 self참조가 가리키는 객체에서 메서드 탐색 실행
        - 그래서 상속 계층 중간에 숨겨져있는 오버라이딩은 이해하기 어려운 코드를 만듬
- 이해할 수 없는 메시지
    - 정적 타입 -> 컴파일 시점에 메시지 탐색하며 올라가다가 못찾으면 컴파일에러 발생
    - 동적 타입 -> 코드 실행해보기전에는 처리 가능 여부 몰라서 예외 발생
        - 예외 발생 말고, 이해못하는 메시지에 응답하는 방식으로 처리도 가능
- self 대 super
    - super
        - 부모 클래스부터 메서드 탐색하겠다.
        - 컴파일 시점에 메서드 탐색할 클래스 정해짐
    - self
        - 나부터 메서드 탐색하겠다.

### 상속 대 위임

- 위임과 self 참조
    - 메서드 탐색중에는 자식클래스의 인스턴스와 부모 클래스의 인스턴스가 동일한 self 참조 공유
    - 위임
        - 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리 요청
        - self 참조를 인자로 전달한다는 점에서 포워딩과 차이
    - 상속은 위임을 통해 객체 사이를 동적으로 연결하여 구현됨
        - self 참조가 자동으로 전달
- 프로토타입 기반의 객체지향 언어
    - 프로토타입 기반언어에서도 위임을 이용해서 self 참조 자동 전달 가능
        - 자바스크립트의 경우 언어 차원에서 제공하는 prototype 이라는 링크를 통해 위임 가능
