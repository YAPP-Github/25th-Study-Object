## 내용정리

상속의 목적은 코드 재사용이 아니라는 점을 이번장 내내 강조한다.

상속의 일차적인 목적은 코드 재사용이 아닌 **서브타입 구현**이다.

### 동적바인딩

객체가 메세지를 수신하면 self참조라는 임시 변수를 자동으로 생성하고 해당 변수가 참조한 객체로부터 주어진 메세지를 처리할 것을 요청한다.

만약 해당 객체가 메세지를 처리할 능력이 없다면 상위타입으로 이동하여 메세지를 처리할 수 있는 메서드를 탐색하는 과정을 거친다.

이것을 상속 계층을 통해 메세지를 처리할 것을 상위 객체에게 `위임`한다고 표현한다.

위임과정은 동적으로 진행되며 그 시작점은 self변수가 참조중인 객체이다.

self변수는 최초로 메세지를 수신한 객체를 참조한다.

### 동적바인딩시 주의할점

특정타입이 메서드를 수신했을 때 해당 타입이 호출할 메서드는 정적으로 결정할 수 없다.

해당 매서드가 하위타입에 의해 재정의 됬을 수 있기 때문이다.

하위객체의 오버라이딩이 상위객체의 매서드 호출에 영향을 미친다는 것이 다소 의아할 수 있다.

```swift
let instance: Super = Child()
instance.someMethod() // Super? Child?
```

이때는 self가 참조하는 객체에 메세지를 전달한다고 표현하는 것이 옳다. 

그리고 여기서 self가 참조하는 객체는 메세지를 최초로 수신하여 탐색을 주도하는 객체이다.

따라서 해당 매서드는 오버라이딩을 통해 하위 타입의 매서드가 호출될 수 있다.

※ 상속 계층을 통해 메서드를 탐색하는 과정에서 동일한 self를 사용한다고 생각하면 된다.

이를 통해 상속계층 내에서의 매서드호출은 모두 위임 방식으로 동작한다.

해당 위임 프로세스를 자동화 해주는 것이 대부분의 언어의 상속 시스템이다.

위음 프로세스는 상속을 굳으 사용할 필요 없이 직접구현하는 것이 가능하다. 하지만 보일러 플레이트이기에 언어 레벨에 지원하는 것이다.

<aside>

이러한 위임은 런타임에 매세지를 처리할 수 있는 객체가 정해지고 그 문맥에 따라 동적으로 호출될 메세드가 결정된다는 점에서 유연하다. 하지만 복잡하고 정적 코드 분석을 어렵게한다.

</aside>

- **super프로퍼티**
    
    super프로퍼티는 현재 객체의 바로 다음 상위 타입을 가리킨다. 
    
    이 경우 super를 통해 매서드를 호출하는 경우 탐색의 시작점이 바로 다음 상위 객체임을 명시적으로 표현한 것이다.
    

### 컴파일 언어와 동적 언어의 차이

컴파일 언어는 컴파일 단계에서 특정 객체가 받은 메시지(메서드 호출 등)가 정확히 어떤 메서드로 처리될지 컴파일러가 확인할 수 있습니다. 이로 인해 컴파일 타임에 많은 오류를 미리 탐지할 수 있으며, 실행 전 안정성을 확보할 수 있다.

하지만 이를 위해서는 메시지를 수신하는 객체의 타입과 상속 계층 구조를 명확히 파악하고 있어야 하며, 타입 시스템에 제약이 따른다.

반면, 동적 언어는 런타임에 메시지를 전달하며, 그 메시지를 실제로 처리할 수 있는지는 실행 도중에 판단한다.

따라서 컴파일 시점에는 해당 메시지를 처리할 메서드가 존재하는지 보장할 수 없고, 런타임 에러 가능성이 존재한다. 하지만 이 유연성 덕분에 객체지향적인 사고 즉, “메시지를 보내기만 하면 된다”는 철학에 더 가까운 코딩이 가능하며, 상속 구조에 대한 사전 파악 없이도 객체 간 협력이 가능하다.

## 느낀점(개선할점)

상속은 메세지 처리에 대한 위임을 통해 다형성을 확보한다. 

단순히 코드 재사용을 목적으로 사용한다기엔 더 많은 장점과 활용방안이 있다.
