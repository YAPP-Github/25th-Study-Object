## 내용정리

### 클라이언트-서버 모델

협력관계를 설명하기위한 전통적인 메타포이다.

협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용이다.

객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.

메세지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

메세지는 오퍼레이션 명과 인자로 구성된다.

메세지를 전송한다는 다음과 같이 구성된다. `수신자, 오퍼레이션명, 인자`

### 메세지와 메서드

메세지는 전통적인 방식의 함수호출 혹은 프로시저 호출과 다르다.

전통적인 방식은 호출하는 송신자 입장에서 해당 코드를 이미 파악한 상태로 호출한다. 즉, 내부동작이 결정된 이후를 전제로한다. (= 컴파일 시간결정)

메세지는 전통적인 방식과 달리 **실행시간에 매서드를 메세지에 바인딩**한다.

### 시그니처

`오퍼레이션의 이름`과 `파라미터 목록`을 합쳐 시그니쳐라고 부린다.

오퍼레이션은 실행코드 없이 시그니처만을 정의한 것이다. 실행 코드는 동적으로 바인딩된다.

## 인터페이스 설계 품질

좋은 인터페이스는 `최소한의 인터페이스`와 `추상적인 인터페이스`를 만족해야한다.

두가지 조건을 동시에 만족시키는 가장좋은 방법은 책임 주도 설계를 지향하는 것이다.

### 디미터 법칙

객체 **내부구조에 외부 사항들이 결합을 통해서 발생하는 문제**를 해결하기 위한 윈칙이다.

디미터 법칙을 요약하자면 아래와 같다.

- 낯선자에게 말하지 말라
- 오직 인접한 이웃하고만 말해라

특정 메서드 내에 접근가능한 객체에 대해 점(dot)하나만 사용해라로 일축할 수 있다.

점을 통해 마구 연결된 코드는 캡슐화에 위배된다.

이러한 코드를 기차충돌 코드라고한다.

```swift
meal.fruit.apple.eat()
```

※ 디미터 법칙은 점을 하나만 사용할 것을 강제하는 원칙은 아니다, 내구 구현을 드러내지 않는 다면 충분히 용인 가능하다. 즉, 중요한 것은 **내부구현을 외부로 노출시키는 것을 최소화** 하는 것이다.

### 묻지말고 시켜라

디미터 법칙은 훌륭한 객체에 대해 다음과 같이 말한다.

**해당 객체의 상태에 대해 묻지말고** 원하는 것을 시키는 객체

<aside>

절차지향적 코드는 **정보를 얻은 이후에 다음 스탭을 결정**한다.

객체지향적 코드는 **정보와 동작을 모두 객체내에서 처리**하도록 함으로써 차이를 보인다.

</aside>

### 의도를 드러내는 인터페이스

어떻게 수행하는 지를 들어내는 이름이란 매서드의 내부 구현을 설명하는 이름이다, 즉 해당 네이밍은 객체의 자율성을 크게 침해한다.

반면 무엇을 하는지 드러내는 네이밍은 객체가 **협력안에서 수행하는 책임에 대해서만 고려한 결과물**이다.

<aside>

추상 매서드 이름짓는 팁

1. 특정 매서드와 매우다른 구현을 가진 다른 매서드를 떠울린다.
2. 떠올린 매서드에 기존의 이름을 그대로 써라
3. 그렇게 하면 두가지 매서드를 모두 만족시킬 수 있는 추상적인 이름이 떠오를 것이다.
</aside>

## 원칙의 헛점

### 디미터 + 묻말시

디미터 법칙은 기차 충돌을 지양하며 해당 책임을 적절한 객체에게 위임하는 것을 말한다.

하지만 간혹 해당 위임이 특정 기능에 대한 객체의 책임을 여러 객체로 분산시켜버리는 문제를 낳기도 한다. (응집도가 낮아진다.)

해당 문제에 대해 책에서 든 예시로

할인조건 객체는 상영 객체를 인자로 전달받고 내부 상태에 접근하여 할인 가능성을 판단한다. 

이 것은 언듯보면 할인조건 객체가 상영객체의 내부상태에 너무 깊게 관여한다고 볼 수 있다.

따라서 디미터 법칙에 의해 할인 조건 계산을 상영에게 위임해보자.

이 경우, 영화 예매를 담당하던 상영 객체에 **본질적인 책임 다소 동떨어지는 인터페이스가 추가**하게된다. 

뿐만아니라, 또한 할인조건 판단 **기능에 대한 응집도가 여러 객체로 분산**되어 유지보수에 까다롭다.

## 명령-쿼리 분리 원칙

- 명령: 객체의 상태를 변화시킴
- 쿼리: 객체의 정보를 확인함

하나의 매서드가 명령과 쿼리를 모두 수행할 경우 예상치 못한 동작이 유발될 수 있다.

명령으로 인해 발상한 부수효과가 쿼리에 영향을 끼칠 수 있기 때문이다.

### 함수형 프로그래밍

컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징은 부수효과의 존재 유무이다.

컴퓨터 세상에는 **대입문과 함수라는 특성**이 있다.

- 대입문은 변동 즉 부수효과를 유발한다.
- 대입문을 포함하는 함수는 실행마다 다른 결과를 만들어 낼 수 있다.

수학적 함수는 참조 투명하다, 즉 순수함수라는 의미이다. 실행 순서 및 횟수에 상관 없이 항상 동일한 결과물을 만들어낸다.

함수형 프로그래밍은 부수효과가 발생하지 않는 수학적 함수를 기반으로한다.