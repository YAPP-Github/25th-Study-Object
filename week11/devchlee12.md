### 11장: 합성과 유연한 설계
- 상속과 합성의 차이
- 상속 - 화이트 박스 재사용
    - 의존성이 컴파일 타임에 해결
    - is-a 관계
    - 부모의 구현에 의존
- 합성 - 블랙 박스 재사용
    - 의존성이 런타임에 해결
    - has-a 관계
    - 객체의 퍼블릭 인터페이스에 의존

### 상속을 합성으로 변경하기

- 상속의 3가지 문제점
    - 불필요한 인터페이스 상속
    - 메서드 오버라이딩 오작동
    - 부모 클래스와 자식 클래스의 동시 수정 문제
- 합성을 통해 세가지 문제점 해결 가능
    - 합성 관계로 바꾸면 불필요한 인터페이스가 노출 안됨
    - 퍼블릭 인터페이스를 구현하고 합성관계로 바꿔서 포워딩하면 오작동 해결
    - 합성을 통해 동시수정 문제를 해결할 수 없더라도 영향 범위를 줄일 수는 있음

### 상속으로 인한 조합의 폭발적인 증가

- 만약 상속으로 할인 정책을 구현한다면?
    
    ![image 1](https://github.com/user-attachments/assets/b0fbf2db-dc76-43da-98f8-13b5003caa49)

    
    - 클래스 수 과도하게 늘어남 - 클래스 폭발
        - 하나의 정책을 추가하려 할 때 너무 많은 클래스 추가해야함
            
            ![image 2](https://github.com/user-attachments/assets/336716f7-1c62-4a19-b2c6-5527e6e0abe7)
            
        - 기능추가 뿐만 아니라 기능 수정할 때도 문제임
            - 세금 정책 변경하려면 모든 세금 관련 클래스 다 수정해야함
- 그러니까 그냥 상속을 포기하자

### 합성 관계로 변경하기

- 클래스 폭발이 일어나는 이유는 컴파일 타임에 의존성이 해결되기 때문
- 그러니까 런타임에 의존성을 해결하는 합성을 적용하면 클래스 폭발을 막을 수 있음
- 합성을 적용한 설계- 일반정책
    
    ![image 3](https://github.com/user-attachments/assets/6cdb0eda-b2b0-481e-a162-1f92606fbd85)
    
    - 사실 여기까지는 꼭 상속보다 좋은가?라는 의문이 들 수 있음
- 합성을 적용한 설계 - 부가정책적용
    
    ![image 4](https://github.com/user-attachments/assets/99c6fe53-48e0-4abe-9c25-9b8b3493e9ce)
    
- 이렇게 설계하면 기존 정책과 부가정책을 손쉽게 순서까지 지정해서 합성할 수 있다
    
    ![image 5](https://github.com/user-attachments/assets/0b9ae820-8cf2-41bd-b0d4-95c284158126)
    
- 새로운 정책 추가하기
    
    ![image 6](https://github.com/user-attachments/assets/d28004ca-e779-470f-b6df-a20a2cdce0b9)
    
    - 합성 기반이면 손쉽게 정책을 추가할 수 있다
- 이렇듯 합성을 통해 런타임에 정책들을 조합하는 방식을 사용하면 기능 추가와 기능 수정 면에서 이득을 볼 수 있다
- 객체의 상속은 코드 재사용을 위해 널리 사용되지만, 부모 클래스의 세부 구현에 자식을 결합시키기 때문에 우아한 해결책은 아니다.
    - 따라서 합성을 사용하는것이 더 건전한 결합도를 유지하면서 코드 재사용을 이루는 방법이다.
- 그러면 상속은 사용하면 안될까?
    - 지금까지 살펴본 상속의 단점은 구현 상속에 대한 것이고, 인터페이스 상속은 괜찮다

### 믹스인

- 상속과 합성의 특성을 모두 가진 코드 재사용 방법
    - 이걸 알면 상속과 합성의 장단점을 더 명확히 이해 가능
- 믹스인이란 객체 생성할 때 코드 일부를 클래스 안에 섞어넣는 기법
    - 컴파일 타임에 코드 조각 조합
        - 합성은 런타임이라는 점에서 대비
    - is-a관계가 아니라 코드 섞는 방법
        - 상속은 is-a 관계라는 점에서 대비
    - 믹스인은 클래스와 클래스 사이의 관계를 고정하지 않음
- 트레이트로 부가 정책 구현하기
    
    ![image 7](https://github.com/user-attachments/assets/27755d94-2992-4700-990a-eeb2d48c22ab)
    
    - 트레이트는 이렇게 사용할 수 있는데, RegularPolicy에 TexablePolicy 트레이트를 믹스인하는 것이다
        - 클래스 자신 →  트레이트 → 조상 순으로 직렬화
        - 메서드 내부에서 super 호출하면 다음 단계 메서드 호출
    - 믹스인 되기 전까지는 트레이트의 위치가 결정 안됨
        
        ![image 8](https://github.com/user-attachments/assets/d78f9924-3ff6-4942-bdc4-deadad00a382)
        
        ![image](https://github.com/user-attachments/assets/1eab3a67-1f82-4a51-8aab-cab394a7898b)
        
    - 근데 이러면 어차피 클래스 수 늘어나는거 아닌가?
        - 클래스 폭발 아님?
            - 클래스 폭발 단점의 핵심은 중복 코드
                - 중복코드 없으므로 ㄱㅊ
    - 이렇듯 믹스인을 사용하면 클래스에 대한 변경 또는 확장을 독립적으로 구현하고 차례대로 추가가 가능
