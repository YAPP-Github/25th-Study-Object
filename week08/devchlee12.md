### 의존성 이해하기

- 변경과 의존성
    - 의존성은 실행시점과 구현시점에 따라 의미가 다름
        - 실행 시점
            - 실행시에 의존 대상 객체 존재해야함
        - 구현 시점
            - 의존 대상 객체 변경되면 의존 객체도 함께 변경
    - 의존성을 한눈에 파악하기 위해 그림으로 표현할 수 있음
        
        ![image1](https://github.com/user-attachments/assets/15cacde8-afda-4ca1-9eaa-1b7edbf35070)

        
        - uml에서의 의존으로 해석하면 안됨
- 의존성 전이
    - 의존성은 전이됨
        - a→b→c 의존이면 a는 c 에도 의존 가능
        - 모든 경우에 의존성이 전이되는 것은 아니고, 함께 변경될 때만 의존
        - 캡슐화 잘하면 전파 안됨
    - 클래스에만 국한되는 것은 아니고, 모듈이나 큰 규모의 시스템도 의존성의 대상이 될 수 있음
- 런타임 의존성과 컴파일타임 의존성
    - 컴파일 타임 의존성
        - 컴파일 하는 시점의 의존성이라기 보다는 코드상의 의존성
        - 클래스 사이의 의존성
    - 런타임 의존성
        - 실행되는 시점의 의존성
        - 객체 사이의 의존성
    - 컴파일 타임과 런타임의 의존성은 다를 수 있음
        
        ![image2](https://github.com/user-attachments/assets/b4976d5f-af14-493f-9f4a-083a07180e0c)
        
        - 컴파일 타임에는 DiscountPolicy 에만 의존
        - 런타임에는 구체 클래스에 의존
    - 재사용 가능한 설계를 위해서는 동일한 소스코드 구조로 다양한 실행구조 만들 수 있어야함
        - 컴파일 타임과 런타임 구조 사이가 멀어야함
- 컨텍스트 독립성
    - 구체클래스에 의존하면 클래스가 사용되는 문맥에 강하게 결합됨
    - 문맥에 결합되지 않아서 재사용에 용이하면 컨텍스트 독립
    - 클래스가 실행컨텍스트에 독립적인데 어떻게 런타임에 적절한 객체들과 협력하나
- 의존성 해결하기
    - 의존성 해결
        - 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
        - 해결 방법
            - 객체 생성 시점에 생성자로 의존성 해결
            - 객체 생성 후 setter로 의존성 해결
            - 메서드 실행 시 인자로 의존성 해결

### 유연한 설계

- 의존성과 결합도
    - 객체가 협력하기 위해서는 서로의 책임을 알아야하고, 의존성에 생길 수 밖에 없음
    - 그래서 의존성이 나쁜 건 아니지만 과하면 안됨
    - 그렇다면 바람지간 의존성은 무엇인가
        - 다양한 환경에서 재사용 가능한 의존성
            - 컨텍스트 독립
    - 결합도
        - 의존성의 정도를 상대적으로 표현
- 지식이 결합을 낳는다
    - 결합도의 정도는 한 요소가 의존하는 다른 요소에 대해 알고있는 정보양으로 결정
        - 많이 알수록 강결합
    - 그래서 진짜 필요한 정보외에는 최대한 감춰야함
        - 이걸 어떻게 하나?
- 추상화에 의존하라
    - 결합도 느슨 순위
        - 인터페이스
        - 추상클래스
        - 구체클래스
- 명시적인 의존성
    - 타입을 추상클래스나 인터페이스로 한다고 결합이 느슨해지는게 아님
    - 클래스 안에서 구체클래스에 대한 의존성 모두 제거해야함
    - 의존성을 퍼블릭 인터페이스에 노출
        - 명시적인 의존성이라함
        - setter나 생성자 인자로 받는 것
    - 생성자 내부에서 의존성 만든다면?
        - 숨겨진 의존성
    - 의존성은 명시적이어야한다
- new는 해롭다
    - 구체클래스에 의존할 수 밖에 없음
    - 생성자 인자의 정보를 알아야함
    - so, 결합도 높아짐
    - 해결방법
        - 생성로직과 사용 로직 분리
        - AmountDiscountPolicy를 사용하는 Movie는 객체를 생성하면 안됨
        - 인자로 전달받아야함
- 가끔은 생성해도 무방하다
    - 협력하는 기본 객체 설정하는 경우에 유용
    - 생성자 체이닝 사용
    - 물론 트레이드 오프임
- 표준 클래스에 대한 의존은 해롭지 않다
    - 변경될 확률 없으면 문제 안됨
- 컨텍스트 확장하기
    - 컨텍스트 독립적인 설계를 하면 컨텍스트 확장에 용이함
    - 만약 비할인 정책이 필요하다면?
        - NonDiscountPolicy 만들면 됨
    - 만약 중복 할인 정책이 필요하다면?
        - 중복 할인 Policy 만들면 됨
- 조합 가능한 행동
    - 객체들의 행동을 조합해서 새로운 행동을 이끌어낼 수 있어야함
