## 내용정리

### 의존성이란?

의존성은 방향성을 가지며 역은 성립하지 않는다.

의존관계가 수립될 경우 가장 주의해야할 점은 의존하는 대상이 병경될 때 의존의 주체 역시 변경될 수 있다는 점이다.

### 의존성 전이

의존관계의 연쇄에 의해 의존성이 전이될 수 있다.

하지만 변경의 방향과 캡슐화 정도에 따라 달라진다.

### 런타임, 컴파일 타임 의존성

의존관계를 파악할 때 그것이 코드를 작성하는 시점인지 실행시점인지 파악하는 것은 중요하다.

코드타임의 의존성의 경우 의존의주체가 클래스(객체를 표현하는 도구)로 전락해버린다.

반면 런타임 의존성의 경우 의존관계의 주체들이 객체이다.

다양한 클래스 인스턴스와 협력하기 위해서는 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.

### 컨텍스트 독립성

구체적인 클래스에 의존할 수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합된다.

### 의존성 해결하기

컴파일타임 의존성을 실행 컨텍스트에 맞는 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.

생성자(init)함수를 통한 의존성 주입 및 setter함수를 사용한 동적 의존이 가능하다.

- 생성자
- setter매서드
- 메서드 인자

### 생성은 해롭다

new를 사용한 생성작업을 객체내에서 수행하게  될 경우 결합도를 급격하게 높이게 된다.

인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리함으로써 해당문제를 해결할 수 있다.

생성책임을 외부(클라이언트)로 옮김으로서 올바른 유연성을 확보할 수 있다.

가급적이면 구체 클래스를 직접적으로 사용하는 코드를 최소화 하는 것이 좋다. 

이러한 문제를 해결할 수 있는 방법중 하나로 Factory패턴이 있다.

팩토리에서 모든 구체 타입을 생성하고 객체로 주입하는 패턴이다.

### 조합 가능한 행동

유연하고 재사용 가능한 설계는 객체가 어떻게 하는지를 장황하게 나열하지 않고도 객체들을 조합을 통해 서

무엇을 하는 지를 표한하는 클래스들로 구성된다.

유연한 협력관계를 고려한 코드의 경우 시스템을 이해하기 위해 코드를 일일히 살펴보는 것이 아니라

구체적인 타입이 생성되고 주입되는 부분만 확인하여도 프로그램의 동작 방식을 유추할 수 있게한다.

이러한 방식을 선언적 정의라고 한다.

객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지 표한한 설계다.

## 느낀점(개선할점)

단순히 코드를 수정하는 것을 넘어, 시스템의 동작을 이해하는 점에서도 유연한 협력구조는 유용하다.