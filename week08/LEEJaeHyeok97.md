### 의존성

- 어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 의존성이 존재한다고 한다.
- 결합도와의 차이
    - 의존성은 존재 유무, 결합도는 정도의 차이를 나타낸다.
- 의존성의 다른 의미
    - 실행 시점: 실행 시점에 인스턴스가 정상적 동작하기 위해서는 인스턴스가 존재해야한다.
    - 구현 시점: 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다.
- 의존성은 방향을 가지며 항상 단방향. 역은 성립하지 않는다.
- 의존성은 변경에 의한 영향의 전파 가능성을 암시하고 있음
    - 자신이 의존하는 대상이 변경될 때 함께 변경될 수 있다

### 의존성 전이

- 의존성은 전이 될 수 있다
- 예시) movie → policy → condition
- 내부 구현을 효과적으로 캡슐화하고 있다면 변경이 전파되지 않는다.
- 전이될 수 있다는 특성을 가지고 직접 의존성과 간접 의존성으로 나누기도 한다.
    - 직접 의존성: 한 요소가 다른 요소에 직접 의존하는 경우
    - 간접 의존성: 직접 의존하지는 않지만 의존성 전이에 의해 영향이 전파되는 경우
    - 클래스 뿐만 아니라 모듈, 실행 시스템에서도 의존성이라는 개념이 적용될 수 있다.

### 런타임 의존성과 컴파일 의존성

- 런타임 의존성: 애플리케이션이 실행되는 시점
- 컴파일 타임 의존성: 컴파일 되는 시점을 가리키지만 코드 그자체를 가리키기도 한다.
- 객체지향에서 런타임의 주인공은 객체
- 코드 관점에서 주인공은 클래스

### 컨텍스트 독립성

- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기 더 수월해진다.
- 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대해 구체적인 정보를 최대한 적게 알아야한다.
- 컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있기 때문이다.

### 의존성을 해결하는 방법

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter 메서드를 통해 의존성 해결
- 메서드 실행 시 인자를 이용해 의존성 해결

### 의존성과 결합도

- 두 개념의 차이
- 의존성이 바람직할 때 느슨한 결합도 또는 약한 결합도를 가진다고 한다.
- 의존성이 바람직하지 못할 때 단단한 결합도 또는 강한 결합도를 가진다고 한다.

### 명시적 의존성, 숨겨진 의존성

- 명시적 의존성: 퍼블릭 인터페이스에 노출
- 숨겨진 의존성: 생성자에 숨겨서 넣을지
- 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계

### new 는 해롭다

- 결합도가 높아진다
- 생성자를 통해 생성하는 객체의 모든 속성을 알 가능성이 있다.
- 트레이드오프가 있음..