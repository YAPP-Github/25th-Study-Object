
# 2장 내용정리

## 캡슐화

객체지향의 장점들중 한가지는 도메인 모델을 프로그래밍 상의 객체로 그대로 옮길 수 있다는 점이다. 

왜냐하면 도메인 모델을 설계할 때도 객체지향 형식을 그대로 사용하기 때문이다.

캡슐화는 은닉화를 통해서 특정 객체의 세부사항을 가리는 것이라고 말한다. 

외부엔 불필요한 정보인 세부사항을 외부로 노출하지 않음으로써 해당 정보의 변동파급력을 최소화한다. 

세부사항은 단지 객체가 수행할 수 있는 작업을 위한 내부적인 로직이다, 외부에는 어떤 작업(메세지)를 수행할 수 있는지만 노출한다.

따라서 객체들은 협력 공동체내에서 상호간에 어떤 책임을 수행하는지만 확인하고, 서로 내부 구현에 대해선 알지 못하는 상태가된다.

외부로부터 격리되어 메세지의 처리를 독립적으로 관리하는 객체를 **자울적은 객체**라고한다.

## 상속과 합성

### 상속

상속은 두가지 성질을 가진다.

- 구현 상속
- 인터페이스 상속

구현 상속은 상위 클래스의 코드를 하위 클래스가 그대로 가져오는 즉, 코드 중복을 막는 방법이다.

인터페이스 상속은 단순히 함수를 상속하기 보다, **부모 클래스가 처리할 수 있는 매세지(책임)를 자식도 그대로 처리할 수 있음**을 보이는 것이 인터페이스 상속이다.

### 추상화

추상화의 장점

- 요구사항을 높은 수준에서 서술할 수 있다.
    - 복잡한 세부항을 가려줌으로 가능하다.

- 설계가 유연해진다.
    - 추상화는 상위 개념의 흐름 전체를 추상화할 수 있다. 기존의 흐름을 해치지 않고 구체 적인 세부사항만을 변경해가며 유연성을 확보할 수 있다.
    - 프레임워크, 디자인 패턴 역시 추상화된 상위 개념에 속한다.

### 상속과 합성

코드를 재사용하기위한 방법은 크게 상속과 합성이 있다. 상속을 통한 코드 재사용은 합성에 비해 문제가 많다.

- 캡슐화를 해친다.
    
    상속을 통한 코드 재사용은 캡슐화를 해친다. 왜냐하면 해당 하위 객체가 상위 객체의 함수를 사용하려면, 해당 함수의 내부 구현을 알아야하기 때문이다. 

    즉, 하위 객체가 **상위 객체의 내부 구현사항을 파악**하고 있어야한다.
    
    다른 객체의 내부 즉, 세부사항을 알아야한다는 점에서 캡슐화를 해치고 상위 객체와 하위 객체를 강하게 결합시킨다. 
    
    강한 결합으로 인해 상위 객체에서 해당 함수의 코드가 변경될 경우 하위 객체에 지대한 영향을 미치게 된다.
    

- 유연하지 못한 코드
    
    상속의 경우 부모와 자식의 관계가 컴파일타임에 강하게 결정된다. 상위 클래스를 런타임에 변경할 수 없다. 
    
    따라서 합성에 비해 유연성이 떨어진다.
    

합성의 경우 상속의 2가지 문제점을 모두 해결한다.

- 캡슐화를 해치지 않는다.
    
    합성의 경우 부모-자식 간 계층형 협력이 아닌 일반적인 객체간 수평적인 협력이다. 
    
    객체의 인터페이스를 통해서 다른 객체와 소통함으로써 캡슐화를 지킬 수 있다.
    
- 협력의 대상을 런타임에 결정한다.
    
    협력하는 객체의 인터페이스(코드 레벨 인터페이스)를 통해 협력하는 경우 어떤 구체타입이든 해당 인터페이스에 할당될 수 있다. 
    
    해당 인터페이스를 프로퍼티의 타입으로 가지는 경우 생성자에 전달하는 객체가 무엇인지에 따라 협력이 유연하게 변경될 수 있다.

    즉, 컴파일 타임이 아닌 런타임에 협력 객체가 지정된다. 
    
    이는 협력의 대상(인터페이스 구체타입)이 변경되도 협력하는 객체의 변동을 최소화할 수 있다, 즉 유연한 변경이 가능하다.

# 느낀점

### 의미를 명확하게 하기위한 객체

책에서 돈(자금)을 의미하는 객체의 타입으로 단순히 기본 자료형을 사용하지 않고 **Money**라는 타입을 사용한다. 

해당 객체가 눈에띄는 책임을 가지는 것은 아니여도, **객체정의를 통해 코드의 의미를 좀 더 명확하게 표현**할 수 있다면 

객체를 생성하는 것이 결과적으로 설계의 명확성과 유연성을 높이는 첫걸음이라고 말한다.

### 유연한 설계

메세지(책임)를 처리하는 객체를 하나로 한정하는 것이 유연한 설계를 낳는다.

예를들어 책에서는 할인 정책이 없는 영화 상영에 대한 처리를 논했다. 할인 정책 객체는 원래 할인 금액을 결정하는 역할을 수행한다. 

할일 정책이 없기 때문에 영화 상영 객체는 **해당 경우를 예외 케이스로 처리하고 분기문을 작성해 할인금액 0원을 적용**시켜야한다.

이는, 일관성이 떨어져 가독성을 해치는 설계라고 말할 수 있다. 예외케이스가 늘어나면, 책임이 분산되고 수정해야할 부분이 기하급수적으로 늘어나게 된다.

따라서 책에서는 할인 금액을 결정하는 사항을 여전히 할인 정책 객체에서 처리하도록 하기 위해 `할인정책없음` 객체를 따로 생성하고 내부적으로 할인 금액을 0원을 반환하도록 했다.

**분기문은 변화에 매우 민감하게 반응한다.**

### 그래서 상속은 언제사용해야 할까?

책에서 마지막에 상속보다는 합성을 지향해야 하지만, **메세지처리(매서드)를 재사용하는 경우** 상속이 필요하기도 한다라고 표현했다.

내가 생각하는 상속을 사용해야 하는 경우는 지켜야할(변동이 적어야할) 로직이 있고, 하위 클래스에서 해당 로직을 사용함(super.매서드)과 동시에 확장이 필요한 경우 상속을 사용할 수 있다고 생각한다.