### 개방-폐쇄 법칙

- 코드 수정 안하고 확장 가능하도록해라
- 그걸 어떻게?
- 컴파일 타임 의존성 고정하고 런타임 의존성 변경
    - 런타임 의존성만 바꾸는 방식으로 수정 없이 확장
        
        ![image1](https://github.com/user-attachments/assets/dd10d81a-75cf-4bfc-8184-5d27261cf5d6)
        
- 개방-폐쇄 원칙의 핵심은 추상화
    - 추상화 → 불필요한 부분 생략해서 복잡성 극복
    - 문맥이 생략되므로 문맥에 적합하게 구체화하고 확장 가능
    - 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 결과물
        
        ![image2](https://github.com/user-attachments/assets/0b3d1d8a-b7ae-49b5-87ac-7a629d0a7dc4)
        
        - 변하는 것 → 할인 요금 계산
        - 변하지 않는 것 → 할인 여부 판단 로직
        - 따라서 생략된 것은 할인 요금 계산
- 그렇다면 추상화만 하면 닫혀있는 설계 만들 수 있나?
    - 수정에 대한 영향 최소화하려면 모든 요소가 추상화에 의존해야함
    - 또한 변하지 않는 것과 변하는 것이 무엇인지 이해하고, 추상화의 목적으로 삼아야함

### 생성 사용 분리

- 객체 생성에 대한 지식은 과도한 결합도를 초래함
    
    ![image3](https://github.com/user-attachments/assets/f341b06e-6607-4400-abd6-62b7c0fd82ee)
    
    - 객체의 타입, 생성자에 전달해야하는 인자
- 생성하거나, 메시지 전송만 하면 상관 없는데, 둘다 하니까 문제인 것
    - 이질적인 코드 공존
- 하지만 객체 생성을 피할수는 없으니, 어디에선가는 생성해야함
    - 그래서 생성책임과 사용 책임을 분리해야함
- 어떻게 분리할까?
    - 객체 생성 책임 클라이언트로
        
        ![image4](https://github.com/user-attachments/assets/4e528023-0614-4150-9438-737f8e7acf2e)
        
        - 어떤 것 적용할지는 클라이언트가 알기 때문에 타당
    - FACTORY 추가하기
        - 클라이언트에게도 객체 생성 지식이 새어나가는 걸 막고 싶다면?
        - 객체 생성에 특화된 객체(FACTORY) 생성
            
            ![image5](https://github.com/user-attachments/assets/2c6acc50-e668-4c15-9852-f06fb756541b)
            
        - 클라이언트에게도 사용과 관련된 책임만 남음
        - 순수한 가공물에게 책임 할당하는 것에 대하여
            - 시스템 객체로 분해하는데에는 두가지 방식
                - 표현적 분해
                    - 도메인에 존재하는 사물이나 개념으로 분해
                    - 도메인 객체로만 책임을 수행하면 문제가능성 높아짐
                - 행위적 분해
                    - 행동으로 분해
            - 표현적 분해로는 한계가 있으므로, 행위적 분해를 통해 순수한 가공물을 생성함 → 바람직
                - 따라서 객체지향은 실세계의 모방이 아님
                    - 임의적으로 창조한 추상화 포함하니까
            - 도메인을 반영하되, 너무 얽매이지 말자
                - 대부분의 디자인패턴은 순수한 가공물을 포함함

### 의존성 주입

- 의존성 주입이란
    - 외부의 독립적인 객체가 인스턴스 생성하고 전달해서 의존성 해결
- 의존성 주입의 세가지 방법
    - 생성자 주입 → 생성할 때 생성자로
    - setter 주입 → setter로
        - 장점 : 의존성 대상 런타임에 변경
        - 단점 : 올바른 생성을 위해 어떤 의존성이 필수인지 명시적으로 표현힘듬
    - 메서드 주입 → 실행시 인자로
        - 주입된 의존성이 한두개의 메서드에서만 사용된다면 인자로 전달하는 것이 나을수도
- 숨겨진 의존성은 나쁘다
    - SERVICE LOCATOR 패턴을 생각해보자
        - 이 패턴은 구체 클래스를 보관하다가 요청하는 객체에게 줌
            
            ![image6](https://github.com/user-attachments/assets/cb3be1ca-5e87-4f8a-a86c-97dcc8f39b97)
            
        - 편해보이지만 의존성을 감추는 결과를 가져옴
            - 퍼블릭 인터페이스 어디에도 이 의존성 정보 없음
        - 숨겨진 의존성의 문제점
            - 컴파일 타임이 아닌 런타임에 의존성 문제 발견
            - 단위 테스트 작성도 어려움
            - 의존성의 대상 설정 시점과 의존성 해결 시점이 멀어짐
        - 문제의 원인은 캡슐화 위반
            - 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있어야 훌륭한 캡슐화
                - 사용법 익히려고 내부 봐야하면 문제 있음
        - 의존성 주입은 퍼블릭 인터페이스에 명시적으로 의존성 드러나므로 문제 없음
- 따라서 가능하면 의존성을 명시적으로 표현할 수 있는 기법 사용해라

### 의존성 역전 원칙

- 상위 수준 클래스가 하위 수준 클래스에 의존하면 변경에 취약해짐
    
    ![image7](https://github.com/user-attachments/assets/935337c1-d90d-4829-9ca5-1c576f5123e0)
    
- 상위수준 클래스가 본질을 담고 있는데, 본질이 아닌 것에 영향받으면 안됨
- 그리고 상위 수준 클래스 사용할 때 하위 수준 클래스도 필요해서 재사용 어려움
- 추상화에 의존하는 것을 통해 이런 문제 해결 가능
    
    ![image8](https://github.com/user-attachments/assets/f684f2bd-0cf0-4c9f-b771-f76bac1f3bd6)
    
    - 모든 클래스가 추상클래스에 의존
    - 이를 의존성 역전 원칙이라함
- 의존성 역전 원칙과 패키지
    - 역전은 의존성 방향 뿐만 아니라 인터페이스 소유권에도 적용
    - 객체지향 언어에서 소유권을 결정하는 것은 모듈(패키지)
        
        ![image9](https://github.com/user-attachments/assets/5daa794e-0f04-4731-b5c9-83b08f8d2a46)
        
    - 이 모듈 구조는 의존성 역전 원칙을 따르고 있을까? No!
        - DiscountPolicy 패키지 안에 구체 클래스들도 포함되어있어서 독립적이지 않음
            - 재사용성 저하
        - 심지어 컴파일이 의존성 그래프를 타고 코드 전체로 번질 수 있음 → C++에서의 이야기임
            - 빌드시간 증가
    - 해결 방법
        
        ![image10](https://github.com/user-attachments/assets/8d99f2dd-0b91-4ac8-947c-d7e855716d47)
        
    - SEPARATED INTERFACE 패턴
    - 이제 컨텍스트에서 Movie가 완전 분리
    - 결론은!
        - 인터페이스의 소유권을 클라이언트에게 주어라

### 유연성에 대한 조언

- 유연한 설계는 유연성이 필요할 때만!
    - 유연성을 추구하면 단순 명확한 코드를 포기하게 될 가능성이 큼
    - 즉, 복잡한 설계가 될 수 있다는 것
- 진짜 유연성이 필요한가? 라는 질문을 해야함
    - 유연성은 단순성과 명확성의 희생에서 자라니까
- 또또… 말하지만 협력과 책임이 중요함
    - 이것저것 말했지만 결국 객체가 다른 객체에게 어떤 메시지 전달하는지가 중요
    - 먼저 역할, 책임, 협력에 초점을 맞춰야함
    - 객체의 역할과 책임이 자리를 잡기 전에 성급하게 객체 생성 하지 마라
        - 생성과 관련된 불필요한 세부사항에 객체 결합시키게됨
        - 생성 담당 객체나 메커니즘은 책임 할당의 마지막 단계로 미뤄라
        - 협력 균형 맞추기가 더 중요
            - 협력 균형 맞추면 생성은 간단함
